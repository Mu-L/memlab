"use strict";(self.webpackChunkmemlab_website=self.webpackChunkmemlab_website||[]).push([[692],{1666:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>d,toc:()=>u});var a=n(7462),i=(n(7294),n(3905)),o=n(1698);var l=n(4844);const s={id:"guides-detect-unbound-object"},r="Detect Unbound Object",d={unversionedId:"guides/guides-detect-unbound-object",id:"guides/guides-detect-unbound-object",title:"Detect Unbound Object",description:"Before you start, it is highly recommended that you would want to complete the Detached DOM guidance if you haven't already. The guide will walk you through the initial steps to set up your local machine.",source:"@site/docs/guides/02-detect-unbound-object.mdx",sourceDirName:"guides",slug:"/guides/guides-detect-unbound-object",permalink:"/docs/guides/guides-detect-unbound-object",draft:!1,editUrl:"https://github.com/facebookincubator/memlab/blob/main/website/docs/guides/02-detect-unbound-object.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"guides-detect-unbound-object"},sidebar:"sidebar",previous:{title:"Detached DOM",permalink:"/docs/guides/guides-detached-dom"},next:{title:"How memlab Works",permalink:"/docs/how-memlab-works"}},c={},u=[{value:"Example App under Test",id:"example-app-under-test",level:2},{value:"1. Define a Scenario File",id:"1-define-a-scenario-file",level:2},{value:"2. Run memlab",id:"2-run-memlab",level:2}],m={toc:u};function p(e){let{components:t,...s}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"detect-unbound-object"},"Detect Unbound Object"),(0,i.kt)("p",null,"Before you start, it is highly recommended that you would want to complete the ",(0,i.kt)("a",{parentName:"p",href:"guides-detached-dom"},"Detached DOM")," guidance if you haven't already. The guide will walk you through the initial steps to set up your local machine."),(0,i.kt)("h2",{id:"example-app-under-test"},"Example App under Test"),(0,i.kt)("p",null,"This is file is located at ",(0,i.kt)("inlineCode",{parentName:"p"},"packages/e2e/static/example/pages/examples/unbound-object.jsx")),(0,i.kt)(o.Z,{showLineNumbers:!0,language:"jsx",mdxType:"CodeBlock"},l.Z),(0,i.kt)("h2",{id:"1-define-a-scenario-file"},"1. Define a Scenario File"),(0,i.kt)(o.Z,{language:"jsx",showLineNumbers:!0,mdxType:"CodeBlock"},'// @nolint\n\n// memlab/packages/e2e/static/example/scenario/unbound-object.js\nfunction url() {\n  return "http://localhost:3000/";\n}\n\n// action where you suspect the memory leak might be happening\nasync function action(page) {\n  await page.click(\'a[href="/examples/unbound-object"]\');\n}\n\n// how to go back to the state before actionw\nasync function back(page) {\n  await page.click(\'a[href="/"]\');\n}\n\n// function leakFilter(node, _snapshot, _leakedNodeIds) {\n//   return node.retainedSize > 1000 * 1000;\n// };\n\nmodule.exports = { action, back, url };\n'),(0,i.kt)("p",null,"Let's save this file at ",(0,i.kt)("inlineCode",{parentName:"p"},"~/memlab/scenarios/unbound-object.js"),"."),(0,i.kt)("h2",{id:"2-run-memlab"},"2. Run memlab"),(0,i.kt)("p",null,"This will take about a few minutes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"memlab run --scenario ~/memlab/scenarios/unbound-object.js\n")),(0,i.kt)("p",null,"The result will say that ",(0,i.kt)("inlineCode",{parentName:"p"},"memlab")," didn't find any memory leak. The reason is that currently ",(0,i.kt)("inlineCode",{parentName:"p"},"memlab")," is unable to distinguish between the actual memory leak vs objects that happen to be kept in memory for various reasons (caching etc...)."),(0,i.kt)("p",null,"However, if you want to discover certain objects that are still in memory and meet the specified search criteria that you have, say, all objects whose sizes are greater than ",(0,i.kt)("inlineCode",{parentName:"p"},"2MB"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"memlab")," supports this need by allowing you to define your leak filtering logic."),(0,i.kt)("p",null,"To have custom leak filtering logic, we'll need to uncomment lines 18-20 in our scenario file and export ",(0,i.kt)("inlineCode",{parentName:"p"},"leakFilter")," function. Now let's run ",(0,i.kt)("inlineCode",{parentName:"p"},"memlab")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"--leak-filter")," option set.\n",(0,i.kt)("inlineCode",{parentName:"p"},"leakFilter")," function will be called for every unreleased heap object (",(0,i.kt)("inlineCode",{parentName:"p"},"node"),") allocated by the target interaction."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"memlab run --scenario ~/memlab/scenarios/unbound-object.js\n")),(0,i.kt)("p",null,"The result will look like this.\n",(0,i.kt)("img",{alt:"memlab run result",src:n(7245).Z,width:"1080",height:"726"})),(0,i.kt)("p",null,"As you can see, ",(0,i.kt)("inlineCode",{parentName:"p"},"memlab")," filtered the leak traces accordingly showing the traces whose ",(0,i.kt)("inlineCode",{parentName:"p"},"retainedSize"),"s are greater than ",(0,i.kt)("inlineCode",{parentName:"p"},"2MB"),"."),(0,i.kt)("p",null,"Another alternetive to have custom leak filtering is to define ",(0,i.kt)("inlineCode",{parentName:"p"},"leak-filter.js")," and pass it to ",(0,i.kt)("inlineCode",{parentName:"p"},"memlab"),"."),(0,i.kt)("p",null,"To do that, extract out the ",(0,i.kt)("inlineCode",{parentName:"p"},"leakFilter")," function and save it in a file, say, ",(0,i.kt)("inlineCode",{parentName:"p"},"~/memlab/leak-filters/leak-filter-by-retained-size.js")),(0,i.kt)("p",null,"Now you can pass it to ",(0,i.kt)("inlineCode",{parentName:"p"},"memlab")," like following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"memlab run --scenario ~/memlab/scenarios/unbound-object.js --leak-filter ~/memlab/leak-filters/leak-filter-by-retained-size.js\n")),(0,i.kt)("p",null,"If you need more advanced filtering logic, there are ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebookincubator/memlab/tree/main/packages/cli/src/options/heap/leak-filter/examples/"},"some examples")," you may find useful."))}p.isMDXComponent=!0},4844:(e,t,n)=>{n.d(t,{Z:()=>a});const a='// @nolint\n\nimport Link from \'next/link\';\nimport React from \'react\';\n\nexport default function DetachedDom() {\n\n  const addNewItem = () => {\n    if (!window.leakedObjects) {\n      window.leakedObjects = [];\n    }\n    for (let i = 0; i < 1024; i++) {\n      window.leakedObjects.push(document.createElement(\'div\'));\n    }\n    console.log(\'Detached DOMs are created. Please check Memory tab in devtools\')\n  };\n\n  return (\n    <div className="container">\n      <div className="row">\n        <Link href="/">Go back</Link>\n      </div>\n      <br />\n      <div className="row">\n        <button type="button" className="btn" onClick={addNewItem}>\n          Create detached DOMs\n        </button>\n      </div>\n    </div>\n  );\n}\n'},7245:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/unbound-object-21a4b02ccc4715569c63f5dade563e38.png"}}]);